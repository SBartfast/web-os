/*

Mainly for tuning oscillators at various levels of granularity.

Here, the top 3 knobs are "+" knobs and the bottom 3 are "-" knobs.
The scaling factors for each column are the same (eg, knobs 1 and 5 are in the same
column).

osc_detune.value = GRANULARITY*(M1*KV[1]+M2*KV[2]+M3*KV[3]-(M1*KV[5]+M2*KV[6]+M3*KV[7]));

Want to keep track of the current state of each knob as it is changed. 

Synchronization issues:

When doing nothing onwinblur, if the knobs do not match onwinfocus, we need to
alert to put them back.

Or onwinblur, set the frequency to the current effective frequency (frequency + detune), 
and then onwinblur, do not allow knob updates until all knobs are back at 0.

Also, we can do a keydown event in order to fold the detune into the frequency and
then require that they are all back to 0 before allowing updates again.




This is the central location for interfacing between Synth objects and the real
world of hardware controllers. There can be LOTW system environment variables
which define models of midi/game/USB controllers, etc., and this app can load
have the knowledge of the physical hardware layout, how the mode/meta toggling
controls work, and what kinds of events are generated by the various buttons,
keys and knobs within the various modes.



Want to do hotplugging of midi, gamepad, WebUSB(!) and attach the incoming
events to the parameters. Perhaps we can define nodes in '.synth' files with
'.xsynth' configuration files that will be read and implemented here. Either as
as parameter in the constructor or do something like:

Osc o;
o.xsynth="/path/to/file.xsynth"

Of course, the nodes can be arbitrarily complex abstractions of, e.g. musical instruments,
and the configuration files can likewise be arbitrarily complex.

*/

const KNOBVALS=(globals.AppVars["Synth-KNOBVALS"]||[0,0,0,0,0,0,0,0,0]);
const KV = KNOBVALS;

const log=(...args)=>console.log(...args);
const wrn=(...args)=>console.warn(...args);
const cwarn=wrn;
const err=(...args)=>console.error(...args);
const cerr=err;

const n = arg.NODE || Core.get_appvar(Main.top, "NODE");//Node

const volup = n._winobj.volume_up;
const voldn = n._winobj.volume_dn;
const togmute = n._winobj.toggle_mute;
const setvol = n._winobj.set_volume;

const type = n._type;
const name = n._name;
const win = Main.top;

const OSC_DETUNE_FAC = 0.1;

let t;
let base_det;
let osc_detune;
if (type=="Osc") {
	t = 1;
	base_det = n.frequency.value/OSC_DETUNE_FAC;
cwarn("BASEDET", base_det);
	osc_detune = n.detune;
}

//log(osc_detune);
Main.innerHTML = type;
Main.bgcol="#000";
Main.tcol="#AAA";
n._window = win;
win.title = `${type}\x20(${name})`;

this.onkill = ()=>{
	delete n._window;
};

this.onmidiknob=(e)=>{
	let num = e.knob;
	let val = e.val;
	KNOBVALS[num] = val;
//    let knob = KNOBS[num+""];
//    if (knob) knob(val);
//log(e);
if (num==4){
setvol(val/127);
return;
}
else if (num==8) return;

if (t==1){//Osc
/*
let d = base_det;
if (num==1)d*=1;
else if (num==2)d*=10;
else if (num==3)d*=100;
else if (num==5)d*=-1;
else if (num==6)d*=-10;
else if (num==7)d*=-100;
else return;
*/

//log(d*(KV[1]+5*KV[2]+25*KV[3]))
//osc_detune.value = base_det*(KV[1]+5*KV[2]+25*KV[3]);
//,KV[5],5*KV[6],25*KV[7]);

osc_detune.value = base_det*(KV[1]+5*KV[2]+25*KV[3]-(KV[5]+5*KV[6]+25*KV[7]));


}

}
this.onmidikeydown=e=>{
//    let f = MIDIKEYDOWNS[e.key+""];
//    f&&f();
log(e);
let k = e.key;
if (k==44)return togmute();

if (t==1){
	if (k==48) n.type="sine";
	else if (k==50) n.type="triangle";
	else if (k==52) n.type="square";
	else if (k==53) n.type="sawtooth";
}
};
this.onmidikeyup=e=>{
//    let f = MIDIKEYUPS[e.key+""];
//    f&&f();
log(e);
};

